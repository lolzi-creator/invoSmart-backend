import { Request, Response } from 'express'
import { asyncHandler } from '../middleware/errorHandler'
import { AuthenticatedRequest } from '../types'
import {
  Invoice,
  InvoiceItem,
  InvoiceStatus,
  ApiResponse
} from '../types'
import { config } from '../config'
import { 
  db, 
  supabaseAdmin,
  handleSupabaseError, 
  generateInvoiceNumber,
  generateQRReference,
  generatePaymentReference,
  DatabaseInvoice,
  DatabaseInvoiceItem,
  DatabaseCustomer,
  DatabaseCompany 
} from '../lib/supabase'
import { createAuditLog } from './auditController'
import { EmailService } from '../services/emailService'
import { formatSwissMwst, generateUnifiedInvoicePdfTemplate, InvoicePdfData, generateReminderPdfTemplate, ReminderPdfData } from '../utils/pdfTemplates'

/**
 * Generate and save invoice PDF using unified template
 * Returns the file path if successful, null otherwise
 */
const generateAndSaveInvoicePdf = async (
  invoice: any, // Database invoice with relations
  company: DatabaseCompany,
  customer: DatabaseCustomer
): Promise<string | null> => {
  try {
    console.log('üìÑ Generating PDF for invoice:', invoice.number)
    
    // Fetch and convert logo to base64 if available
    let logoBase64 = null
    if (company.logo_url) {
      try {
        let logoPath = null
        if (company.logo_url.includes('/storage/v1/object/public/logos/')) {
          logoPath = company.logo_url.split('/storage/v1/object/public/logos/')[1].split('?')[0]
        } else if (company.logo_url.includes('/logos/')) {
          logoPath = company.logo_url.split('/logos/')[1].split('?')[0]
        } else if (company.logo_url.startsWith('logos/')) {
          logoPath = company.logo_url.replace('logos/', '').split('?')[0]
        } else {
          logoPath = company.logo_url.split('?')[0]
        }
        
        if (logoPath) {
          const { data: logoData, error: logoError } = await supabaseAdmin.storage
            .from('logos')
            .download(logoPath)
          
          if (!logoError && logoData) {
            const logoBuffer = Buffer.from(await logoData.arrayBuffer())
            const logoMimeType = logoData.type || 'image/png'
            logoBase64 = `data:${logoMimeType};base64,${logoBuffer.toString('base64')}`
          }
        }
      } catch (logoFetchError) {
        console.error('‚ùå Error fetching logo for PDF:', logoFetchError)
      }
    }

    // Determine reference type and IBAN
    const { referenceType, iban } = getReferenceTypeAndIban(invoice.qr_reference, company)

    // Generate Swiss QR code
    const QRCode = require('qrcode')
    const qrPayload = [
      'SPC', '0200', '1',
      iban,
      'S', company.name, company.address, '', company.zip, company.city, 'CH',
      '', '', '', '', '', '', '',
      (invoice.total / 100).toFixed(2), 'CHF',
      'S', customer.name,
      customer.address, '',
      customer.zip, customer.city,
      customer.country || 'CH',
      referenceType,
      invoice.qr_reference,
      `Invoice ${invoice.number}`,
      'EPD'
    ].join('\n')
    
    const qrCodeImage = await QRCode.toDataURL(qrPayload, {
      type: 'image/png',
      width: 140,
      margin: 1,
      color: { dark: '#000000', light: '#FFFFFF' }
    })

    // Get invoice items
    const { data: invoiceItems } = await db.invoiceItems()
      .select('*')
      .eq('invoice_id', invoice.id)
      .order('sort_order', { ascending: true })

    // Generate PDF using unified template
    const htmlTemplate = generateUnifiedInvoicePdfTemplate({
      invoice: {
        number: invoice.number,
        date: invoice.date,
        due_date: invoice.due_date,
        service_date: invoice.service_date,
        qr_reference: invoice.qr_reference,
        subtotal: invoice.subtotal,
        discount_amount: invoice.discount_amount,
        vat_amount: invoice.vat_amount,
        total: invoice.total,
        invoice_items: invoiceItems || []
      },
      customer: {
        name: customer.name,
        company: customer.company,
        address: customer.address,
        zip: customer.zip,
        city: customer.city,
        country: customer.country,
        email: customer.email,
        phone: customer.phone,
        payment_terms: customer.payment_terms
      },
      company: {
        name: company.name,
        address: company.address,
        zip: company.zip,
        city: company.city,
        email: company.email,
        phone: company.phone,
        uid: company.uid,
        vat_number: company.vat_number,
        iban: company.iban,
        qr_iban: company.qr_iban,
        website: company.website
      },
      qrCodeImage,
      logoBase64,
      paymentReference: invoice.qr_reference,
      referenceType,
      iban
    })

    // Generate PDF buffer
    const htmlPdf = require('html-pdf-node')
    const options = {
      format: 'A4',
      margin: { top: '20mm', bottom: '20mm', left: '20mm', right: '20mm' },
      printBackground: true,
      displayHeaderFooter: false,
      timeout: 30000,
      preferCSSPageSize: true,
      emulateMedia: 'print',
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-gpu',
        '--run-all-compositor-stages-before-draw'
      ]
    }
    
    const file = { content: htmlTemplate }
    const pdfBuffer = await htmlPdf.generatePdf(file, options)
    
    // Save to storage
    const sanitizeForPath = (name: string) => {
      return name.replace(/[^a-zA-Z0-9-_]/g, '_').replace(/_+/g, '_').replace(/^_|_$/g, '')
    }
    
    const companyName = sanitizeForPath(company.name || 'Company')
    const customerName = sanitizeForPath(customer.name || 'Customer')
    const invoiceNumber = sanitizeForPath(invoice.number)
    
    const fileName = `Invoice-${invoice.number}.pdf`
    const filePath = `${companyName}/${customerName}/${invoiceNumber}/${fileName}`
    
    // Use upsert: true to overwrite existing PDF
    const { data: uploadData, error: uploadError } = await supabaseAdmin.storage
      .from('invoices')
      .upload(filePath, pdfBuffer, {
        contentType: 'application/pdf',
        upsert: true
      })

    if (uploadError) {
      console.error('‚ùå Failed to upload PDF to storage:', uploadError)
      return null
    }

    console.log('‚úÖ PDF uploaded successfully:', uploadData.path)
    
    // Store file reference in internal_notes
    const fileInfo = {
      id: crypto.randomUUID(),
      fileName: fileName,
      filePath: uploadData.path,
      fileType: 'invoice_pdf',
      uploadedAt: new Date().toISOString()
    }
    
    const currentNotes = invoice.internal_notes || '{}'
    let notesData: any = {}
    try {
      if (currentNotes && currentNotes.trim() !== '' && currentNotes.trim().startsWith('{')) {
        notesData = JSON.parse(currentNotes)
      }
    } catch (e) {
      notesData = { files: [] }
    }
    
    if (!notesData.files) {
      notesData.files = []
    }
    
    // Remove old invoice PDF if exists, add new one
    notesData.files = notesData.files.filter((f: any) => f.fileType !== 'invoice_pdf')
    notesData.files.push(fileInfo)
    
    // Update invoice with file info
    await db.invoices()
      .update({
        internal_notes: JSON.stringify(notesData)
      })
      .eq('id', invoice.id)
    
    console.log('üìÑ PDF file record stored in invoice')
    return uploadData.path
    
  } catch (error) {
    console.error('‚ùå Error generating and saving invoice PDF:', error)
    return null
  }
}

// Helper function to determine reference type and IBAN based on invoice reference
// QR references: 27-digit numeric, only with QR-IBAN
// SCOR references: start with "RF", only with normal IBAN
const getReferenceTypeAndIban = (
  reference: string,
  company: { qr_iban?: string | null, iban?: string | null }
): { referenceType: 'QRR' | 'SCOR', iban: string } => {
  // Check if reference is QR (27-digit numeric) or SCOR (starts with RF)
  const isQRReference = /^\d{27}$/.test(reference)
  const isSCORReference = /^RF\d{2}\d+$/.test(reference)
  
  if (isQRReference) {
    // QR reference must use QR-IBAN
    if (!company.qr_iban || !company.qr_iban.trim()) {
      throw new Error('QR reference requires QR-IBAN, but company has no QR-IBAN configured')
    }
    return {
      referenceType: 'QRR',
      iban: company.qr_iban.replace(/\s/g, '')
    }
  } else if (isSCORReference) {
    // SCOR reference must use normal IBAN
    if (!company.iban || !company.iban.trim()) {
      throw new Error('SCOR reference requires normal IBAN, but company has no IBAN configured')
    }
    return {
      referenceType: 'SCOR',
      iban: company.iban.replace(/\s/g, '')
    }
  } else {
    // Invalid reference format
    throw new Error(`Invalid reference format: must be 27-digit numeric (QR) or start with RF (SCOR), got: ${reference}`)
  }
}


// Helper function to convert DB invoice to API invoice
const createInvoiceResponse = (
  dbInvoice: DatabaseInvoice, 
  customer?: DatabaseCustomer,
  company?: DatabaseCompany,
  items?: DatabaseInvoiceItem[]
): Invoice => {
  return {
    id: dbInvoice.id,
    number: dbInvoice.number,
    customerId: dbInvoice.customer_id,
    customer: customer ? {
      id: customer.id,
      companyId: customer.company_id,
      customerNumber: customer.customer_number,
      name: customer.name,
      company: customer.company || undefined,
      email: customer.email || undefined,
      address: customer.address,
      zip: customer.zip,
      city: customer.city,
      country: customer.country,
      phone: customer.phone || undefined,
      vatNumber: customer.vat_number || undefined,
      paymentTerms: customer.payment_terms,
      creditLimit: customer.credit_limit || undefined,
      isActive: customer.is_active,
      notes: customer.notes || undefined,
      language: customer.language,
      createdAt: new Date(customer.created_at),
      updatedAt: new Date(customer.updated_at)
    } : undefined,
    companyId: dbInvoice.company_id,
    company: company ? {
      id: company.id,
      name: company.name,
      address: company.address,
      zip: company.zip,
      city: company.city,
      country: company.country,
      phone: company.phone || undefined,
      email: company.email,
      website: company.website || undefined,
      uid: company.uid || undefined,
      vatNumber: company.vat_number || undefined,
      iban: company.iban || undefined,
      qrIban: company.qr_iban || undefined,
      logoUrl: company.logo_url || undefined,
      defaultPaymentTerms: company.default_payment_terms,
      defaultLanguage: company.default_language,
      createdAt: new Date(company.created_at),
      updatedAt: new Date(company.updated_at)
    } : undefined,
    date: new Date(dbInvoice.date),
    dueDate: new Date(dbInvoice.due_date),
    serviceDate: new Date(dbInvoice.service_date), // Leistungsdatum
    status: dbInvoice.status as InvoiceStatus,
    subtotal: dbInvoice.subtotal / 100, // Convert Rappen to CHF
    vatAmount: dbInvoice.vat_amount / 100, // Convert Rappen to CHF
    total: dbInvoice.total / 100, // Convert Rappen to CHF
    paidAmount: dbInvoice.paid_amount / 100, // Convert Rappen to CHF
    qrReference: dbInvoice.qr_reference,
    reminderLevel: dbInvoice.reminder_level,
    lastReminderAt: dbInvoice.last_reminder_at ? new Date(dbInvoice.last_reminder_at) : undefined,
    sentAt: dbInvoice.sent_at ? new Date(dbInvoice.sent_at) : undefined,
    emailSentCount: dbInvoice.email_sent_count,
    discountCode: dbInvoice.discount_code || undefined,
    discountAmount: dbInvoice.discount_amount / 100, // Convert Rappen to CHF
    internalNotes: dbInvoice.internal_notes || undefined,
    items: items ? items.map(createInvoiceItemResponse) : [],
    payments: [], // Would need to be loaded separately
    createdAt: new Date(dbInvoice.created_at),
    updatedAt: new Date(dbInvoice.updated_at)
  }
}

// Helper function to convert DB invoice item to API invoice item
const createInvoiceItemResponse = (dbItem: DatabaseInvoiceItem): InvoiceItem => {
  return {
    id: dbItem.id,
    invoiceId: dbItem.invoice_id,
    description: dbItem.description,
    quantity: dbItem.quantity / 1000, // Convert from 3 decimal precision (1500 = 1.5)
    unit: dbItem.unit,
    unitPrice: dbItem.unit_price / 100, // Convert Rappen to CHF
    discount: dbItem.discount / 100, // Convert from basis points to percentage
    vatRate: dbItem.vat_rate / 100, // Convert from basis points to percentage
    lineTotal: dbItem.line_total / 100, // Convert Rappen to CHF
    vatAmount: dbItem.vat_amount / 100, // Convert Rappen to CHF
    sortOrder: dbItem.sort_order
  }
}

/**
 * @desc    Get all invoices
 * @route   GET /api/v1/invoices
 * @access  Private
 */
export const getInvoices = asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
  const companyId = req.user?.companyId
  
  if (!companyId) {
    res.status(401).json({
      success: false,
      error: 'Authentication required'
    })
    return
  }

  // Parse query parameters
  const page = parseInt(req.query.page as string) || 1
  const limit = parseInt(req.query.limit as string) || 5
  const search = req.query.search as string || ''
  const status = req.query.status as InvoiceStatus
  const sortBy = req.query.sortBy as string || 'date'
  const sortOrder = req.query.sortOrder as string || 'desc'

  try {
    // Build query with joins
    let query = db.invoices()
      .select(`
        *,
        customers (
          id, company_id, customer_number, name, company, email, 
          address, zip, city, country, phone, vat_number, 
          payment_terms, credit_limit, is_active, notes, language,
          created_at, updated_at
        )
      `, { count: 'exact' })
      .eq('company_id', companyId)

    // Apply filters
    if (status) {
      query = query.eq('status', status)
    }

    if (search) {
      // Search on direct columns: number and qr_reference
      // PostgREST .or() syntax: "col1.oper.val1,col2.oper.val2"
      console.log('[Invoice Search] Searching for:', search)
      
      // Use same pattern as other controllers: embed % directly in the query string
      // Try both exact match (eq) and partial match (ilike) for QR reference
      query = query.or(`number.ilike.%${search}%,qr_reference.ilike.%${search}%,qr_reference.eq.${search}`)
      
      console.log('[Invoice Search] Query OR clause:', `number.ilike.%${search}%,qr_reference.ilike.%${search}%,qr_reference.eq.${search}`)
    }

    // Apply sorting
    const ascending = sortOrder === 'asc'
    query = query.order(sortBy, { ascending })

    // Apply pagination
    const from = (page - 1) * limit
    const to = from + limit - 1
    query = query.range(from, to)

    const { data, error, count } = await query

    if (error) {
      console.error('[Invoice Search] Query error:', error)
      handleSupabaseError(error, 'get invoices')
      return
    }

    console.log('[Invoice Search] Found', data?.length || 0, 'invoices (from query)')
    if (search) {
      // Debug: Also try a simple query to see if invoice exists at all
      const { data: debugData } = await db.invoices()
        .select('id, number, qr_reference, company_id')
        .eq('company_id', companyId)
        .eq('qr_reference', search)
        .limit(5)
      console.log('[Invoice Search] Direct QR reference query (exact match):', debugData?.length || 0, 'invoices')
      if (debugData && debugData.length > 0) {
        console.log('[Invoice Search] Direct match invoices:', debugData)
      }
      
      if (data) {
        console.log('[Invoice Search] Invoices from search query with QR references:', data.map((inv: any) => ({
          number: inv.number,
          qr_reference: inv.qr_reference,
          id: inv.id
        })))
      }
    }

    let invoices = (data as any[]).map(invoice => 
      createInvoiceResponse(invoice, invoice.customers, undefined, invoice.invoice_items)
    )

    // Filter by customer name if search didn't match number/qr_reference
    // (PostgREST doesn't support searching joined table columns in .or() queries)
    if (search && invoices.length === 0) {
      // If no results from direct column search, try fetching all and filtering by customer name
      const allQuery = db.invoices()
        .select(`
          *,
          customers (
            id, company_id, customer_number, name, company, email, 
            address, zip, city, country, phone, vat_number, 
            payment_terms, credit_limit, is_active, notes, language,
            created_at, updated_at
          )
        `, { count: 'exact' })
        .eq('company_id', companyId)
      
      if (status) {
        allQuery.eq('status', status)
      }
      
      const { data: allInvoices } = await allQuery
      
      if (allInvoices) {
        const searchLower = search.toLowerCase()
        invoices = allInvoices
          .filter((inv: any) => 
            inv.customers?.name?.toLowerCase().includes(searchLower) ||
            inv.customers?.company?.toLowerCase().includes(searchLower)
          )
          .slice(0, limit)
          .map((invoice: any) => 
            createInvoiceResponse(invoice, invoice.customers, undefined, invoice.invoice_items)
          )
      }
    }

    res.json({
      success: true,
      data: {
        invoices,
        pagination: {
          page,
          limit,
          total: count || 0,
          pages: Math.ceil((count || 0) / limit)
        }
      }
    })

  } catch (error) {
    handleSupabaseError(error, 'get invoices')
  }
})

/**
 * @desc    Get single invoice
 * @route   GET /api/v1/invoices/:id
 * @access  Private
 */
export const getInvoice = asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
  const companyId = req.user?.companyId
  const invoiceId = req.params.id

  if (!companyId) {
    res.status(401).json({
      success: false,
      error: 'Authentication required'
    })
    return
  }

  try {
    // Get invoice with customer and items
    const { data: invoiceData, error: invoiceError } = await db.invoices()
      .select(`
        *,
        customers (*),
        companies (*),
        invoice_items (*)
      `)
      .eq('id', invoiceId)
      .eq('company_id', companyId)
      .single()

    if (invoiceError || !invoiceData) {
      res.status(404).json({
        success: false,
        error: 'Invoice not found'
      })
      return
    }

    // Get matched payments for this invoice
    const { data: paymentsData, error: paymentsError } = await db.payments()
      .select('*')
      .eq('invoice_id', invoiceId)
      .eq('company_id', companyId)
      .eq('is_matched', true)
      .order('value_date', { ascending: false })

    const invoice = createInvoiceResponse(
      invoiceData,
      invoiceData.customers,
      invoiceData.companies,
      invoiceData.invoice_items
    )

    // Add payments to invoice response
    if (!paymentsError && paymentsData) {
      invoice.payments = paymentsData.map((payment: any) => ({
        id: payment.id,
        invoiceId: payment.invoice_id || undefined,
        companyId: payment.company_id,
        amount: payment.amount, // In Rappen
        valueDate: new Date(payment.value_date),
        reference: payment.reference || undefined,
        description: payment.description || undefined,
        confidence: payment.confidence,
        isMatched: payment.is_matched,
        importBatch: payment.import_batch || undefined,
        createdAt: new Date(payment.created_at),
        updatedAt: new Date(payment.updated_at)
      }))
    } else {
      invoice.payments = []
    }

    // Parse files from internal_notes if present
    if (invoiceData.internal_notes) {
      try {
        const notesData = JSON.parse(invoiceData.internal_notes)
        if (notesData && Array.isArray(notesData.files)) {
          // Generate signed URLs for files
          const filesWithUrls = await Promise.all(
            notesData.files.map(async (file: any) => {
              try {
                const { data: signedUrlData } = await supabaseAdmin.storage
                  .from('invoices')
                  .createSignedUrl(file.filePath, 3600) // 1 hour expiry
                
                return {
                  ...file,
                  downloadUrl: signedUrlData?.signedUrl || null
                }
              } catch (e) {
                console.error('Error generating signed URL for file:', e)
                return {
                  ...file,
                  downloadUrl: null
                }
              }
            })
          )
          ;(invoice as any).files = filesWithUrls
        }
      } catch (e) {
        // If parsing fails, no files
        ;(invoice as any).files = []
      }
    } else {
      ;(invoice as any).files = []
    }

    res.json({
      success: true,
      data: { invoice }
    })

  } catch (error) {
    handleSupabaseError(error, 'get invoice')
  }
})

/**
 * @desc    Create new invoice
 * @route   POST /api/v1/invoices
 * @access  Private
 */
export const createInvoice = asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
  const companyId = req.user?.companyId

  if (!companyId) {
    res.status(401).json({
      success: false,
      error: 'Authentication required'
    })
    return
  }

  const {
    customerId,
    date = new Date(),
    dueDate,
    serviceDate, // Leistungsdatum (zwingend erforderlich)
    items = [],
    notes,
    discountCode
  } = req.body

  // Validate required fields
  if (!serviceDate) {
    res.status(400).json({
      success: false,
      error: 'Leistungsdatum ist zwingend erforderlich f√ºr die MWST-Abrechnung'
    })
    return
  }

  try {
    // Get company data first (needed for reference generation)
    const { data: company, error: companyError } = await db.companies()
      .select('id, qr_iban, iban')
      .eq('id', companyId)
      .single()

    if (companyError || !company) {
      res.status(404).json({
        success: false,
        error: 'Company not found'
      })
      return
    }

    // Verify customer exists and belongs to company
    const { data: customer, error: customerError } = await db.customers()
      .select('*')
      .eq('id', customerId)
      .eq('company_id', companyId)
      .single()

    if (customerError || !customer) {
      res.status(404).json({
        success: false,
        error: 'Customer not found'
      })
      return
    }

    // Generate invoice number and payment reference (QR or SCOR based on IBAN setup)
    const invoiceNumber = await generateInvoiceNumber(companyId)
    const { reference: paymentReference } = await generatePaymentReference(invoiceNumber, companyId, company)

    // Calculate due date if not provided
    let calculatedDueDate = dueDate
    if (!calculatedDueDate) {
      const invoiceDate = new Date(date)
      calculatedDueDate = new Date(invoiceDate.getTime() + customer.payment_terms * 24 * 60 * 60 * 1000)
    } else if (typeof calculatedDueDate === 'string') {
      calculatedDueDate = new Date(calculatedDueDate)
    }

    // Calculate totals from items
    let subtotal = 0
    let vatTotal = 0
    let discountAmount = 0

    const processedItems = items.map((item: {
      description: string
      quantity: number
      unit?: string
      unitPrice: number
      discount?: number
      vatRate?: number
    }, index: number) => {
      // Calculate amounts in CHF
      const lineTotal = item.quantity * item.unitPrice * (1 - (item.discount || 0) / 100)
      const vatAmount = lineTotal * (item.vatRate || 0) / 100
      
      subtotal += lineTotal
      vatTotal += vatAmount

      return {
        description: item.description,
        quantity: Math.round(item.quantity * 1000), // Convert to 3 decimal precision (1.5 = 1500)
        unit: item.unit || 'Stk',
        unit_price: Math.round(item.unitPrice * 100), // Convert CHF to Rappen
        discount: Math.round((item.discount || 0) * 100), // Convert to basis points
        vat_rate: Math.round((item.vatRate || 0) * 100), // Convert to basis points
        line_total: Math.round(lineTotal * 100), // Convert CHF to Rappen
        vat_amount: Math.round(vatAmount * 100), // Convert CHF to Rappen
        sort_order: index + 1
      }
    })

    // Apply discount code if provided
    if (discountCode) {
      const { data: discount } = await db.discountCodes()
        .select('*')
        .eq('code', discountCode)
        .eq('company_id', companyId)
        .eq('is_active', true)
        .single()

      if (discount) {
        discountAmount = Math.round(subtotal * discount.percentage / 10000 * 100) / 100
      }
    }

    const total = subtotal + vatTotal - discountAmount


    // Create invoice
    const invoiceData = {
      company_id: companyId,
      customer_id: customerId,
      number: invoiceNumber,
      qr_reference: paymentReference, // Can be QR (27-digit) or SCOR (RF prefix) reference
      status: 'DRAFT' as InvoiceStatus,
      date: typeof date === 'string' ? date : date.toISOString().split('T')[0],
      due_date: typeof calculatedDueDate === 'string' ? calculatedDueDate : calculatedDueDate.toISOString().split('T')[0],
      service_date: typeof serviceDate === 'string' ? serviceDate : new Date(serviceDate).toISOString().split('T')[0], // Leistungsdatum
      subtotal: Math.round(subtotal * 100), // Convert CHF to Rappen
      vat_amount: Math.round(vatTotal * 100), // Convert CHF to Rappen
      total: Math.round(total * 100), // Convert CHF to Rappen
      paid_amount: 0,
      reminder_level: 0,
      email_sent_count: 0,
      discount_code: discountCode || null,
      discount_amount: Math.round(discountAmount * 100) // Convert CHF to Rappen
    }

    const { data: newInvoice, error: invoiceCreateError } = await db.invoices()
      .insert(invoiceData)
      .select()
      .single()

    if (invoiceCreateError || !newInvoice) {
      handleSupabaseError(invoiceCreateError, 'create invoice')
      return
    }

    // Create invoice items
    if (processedItems.length > 0) {
      const itemsWithInvoiceId = processedItems.map((item: any) => ({
        ...item,
        invoice_id: newInvoice.id
      }))

      const { error: itemsError } = await db.invoiceItems()
        .insert(itemsWithInvoiceId)

      if (itemsError) {
        // Cleanup: delete invoice if items creation fails
        await db.invoices().delete().eq('id', newInvoice.id)
        handleSupabaseError(itemsError, 'create invoice items')
        return
      }
    }

    // Get complete invoice with relations
    const { data: completeInvoice, error: fetchError } = await db.invoices()
      .select(`
        *,
        customers (*),
        companies (*),
        invoice_items (*)
      `)
      .eq('id', newInvoice.id)
      .single()

    if (fetchError || !completeInvoice) {
      handleSupabaseError(fetchError, 'fetch complete invoice')
      return
    }

    const invoice = createInvoiceResponse(
      completeInvoice,
      completeInvoice.customers,
      completeInvoice.companies,
      completeInvoice.invoice_items
    )

    // Generate and save PDF automatically using unified template
    try {
      const { data: companyForPdf } = await db.companies()
        .select('*')
        .eq('id', companyId)
        .single()

      if (companyForPdf && completeInvoice.customers) {
        await generateAndSaveInvoicePdf(
          completeInvoice,
          companyForPdf,
          completeInvoice.customers
        )
      }
    } catch (pdfError) {
      console.error('‚ùå Error generating PDF on invoice creation:', pdfError)
      // Don't fail the invoice creation if PDF generation fails
    }

    // Log audit event
    try {
      await createAuditLog(
        companyId,
        req.user!.id,
        req.user!.name,
        'INVOICE_CREATED',
        'INVOICE',
        invoice.id,
        {
          invoiceNumber: invoice.number,
          customerId: invoice.customerId,
          customerName: invoice.customer?.name,
          total: invoice.total,
          status: invoice.status
        },
        req.ip,
        req.get('User-Agent')
      )
    } catch (auditError) {
      console.error('Error creating audit log:', auditError)
    }

    res.status(201).json({
      success: true,
      message: 'Invoice created successfully',
      data: { invoice }
    })

  } catch (error) {
    handleSupabaseError(error, 'create invoice')
  }
})

/**
 * @desc    Update invoice status
 * @route   PUT /api/v1/invoices/:id/status
 * @access  Private
 */
export const updateInvoiceStatus = asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
  const companyId = req.user?.companyId
  const invoiceId = req.params.id
  const { status } = req.body

  if (!companyId) {
    res.status(401).json({
      success: false,
      error: 'Authentication required'
    })
    return
  }

  try {
    const updateData: any = { status }

    // Set sentAt when status changes to OPEN
    if (status === 'OPEN') {
      updateData.sent_at = new Date().toISOString()
      updateData.email_sent_count = 1
    }

    const { data, error } = await db.invoices()
      .update(updateData)
      .eq('id', invoiceId)
      .eq('company_id', companyId)
      .select()
      .single()

    if (error || !data) {
      res.status(404).json({
        success: false,
        error: 'Invoice not found'
      })
      return
    }

    // If status set to OPEN, generate PDF and send invoice notification email
    if (status === 'OPEN') {
      try {
        // Load invoice with all relations (including items)
        const { data: fullInvoice, error: fetchError } = await db.invoices()
          .select(`*, customers (*), companies (*), invoice_items (*)`)
          .eq('id', invoiceId)
          .eq('company_id', companyId)
          .single()

        if (!fetchError && fullInvoice && fullInvoice.customers && fullInvoice.companies) {
          // Generate and save PDF first (using unified template)
          await generateAndSaveInvoicePdf(
            fullInvoice,
            fullInvoice.companies,
            fullInvoice.customers
          )

          // Then send email with PDF attachment
          if (fullInvoice.customers.email) {
            const emailService = EmailService.getInstance()
            const result = await emailService.sendInvoiceNotification({
              invoice: fullInvoice as any,
              customer: fullInvoice.customers,
              company: fullInvoice.companies
            })
            
            if (result?.success) {
              await db.invoices()
                .update({
                  sent_at: new Date().toISOString(),
                  email_sent_count: (data.email_sent_count || 0) + 1
                })
                .eq('id', invoiceId)
                .eq('company_id', companyId)
            } else {
              console.warn('Email send failed on status OPEN:', result?.error)
            }
          }
        } else {
          console.warn('Invoice/customer/company data not ready for PDF generation and email on OPEN', fetchError)
        }
      } catch (error) {
        console.error('Error generating PDF and sending email on status OPEN:', error)
      }
    }

    // Log audit event
    try {
      await createAuditLog(
        companyId,
        req.user!.id,
        req.user!.name,
        'INVOICE_STATUS_UPDATED',
        'INVOICE',
        invoiceId,
        {
          invoiceNumber: data.number,
          oldStatus: data.status,
          newStatus: status
        },
        req.ip,
        req.get('User-Agent')
      )
    } catch (auditError) {
      console.error('Error creating audit log:', auditError)
    }

    res.json({
      success: true,
      message: 'Invoice status updated successfully',
      data: { invoice: createInvoiceResponse(data) }
    })

  } catch (error) {
    handleSupabaseError(error, 'update invoice status')
  }
})

/**
 * @desc    Get invoice statistics
 * @route   GET /api/v1/invoices/stats
 * @access  Private
 */
export const getInvoiceStats = asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
  const companyId = req.user?.companyId

  if (!companyId) {
    res.status(401).json({
      success: false,
      error: 'Authentication required'
    })
    return
  }

  try {
    // Get all invoices for stats
    const { data: invoices, error } = await db.invoices()
      .select('status, total, paid_amount, date')
      .eq('company_id', companyId)

    if (error) {
      handleSupabaseError(error, 'get invoice stats')
      return
    }

    // Calculate statistics
    const totalInvoices = invoices?.length || 0
    const totalRevenue = invoices?.reduce((sum, inv) => sum + inv.total, 0) || 0
    const totalPaid = invoices?.reduce((sum, inv) => sum + inv.paid_amount, 0) || 0
    const totalOutstanding = totalRevenue - totalPaid

    const statusCounts = invoices?.reduce((acc, inv) => {
      acc[inv.status] = (acc[inv.status] || 0) + 1
      return acc
    }, {} as Record<string, number>) || {}

    const stats = {
      totalInvoices,
      totalRevenue,
      totalPaid,
      totalOutstanding,
      statusCounts,
      averageInvoiceValue: totalInvoices > 0 ? Math.round(totalRevenue / totalInvoices) : 0
    }

    res.json({
      success: true,
      data: { stats }
    })

  } catch (error) {
    handleSupabaseError(error, 'get invoice stats')
  }
})

/**
 * @desc    Generate Swiss QR code data
 * @route   GET /api/v1/invoices/:id/qr
 * @access  Private
 */
export const generateInvoiceQR = asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
  const companyId = req.user?.companyId
  const invoiceId = req.params.id

  if (!companyId) {
    res.status(401).json({
      success: false,
      error: 'Authentication required'
    })
    return
  }

  try {
    // Get invoice with company and customer data
    const { data: invoice, error: invoiceError } = await db.invoices()
      .select(`
        *,
        customers (
          id, name, company, address, zip, city, country
        )
      `)
      .eq('id', invoiceId)
      .eq('company_id', companyId)
      .single()

    if (invoiceError || !invoice) {
      res.status(404).json({
        success: false,
        error: 'Invoice not found'
      })
      return
    }

    // Get company data
    const { data: company, error: companyError } = await db.companies()
      .select('*')
      .eq('id', companyId)
      .single()

    if (companyError || !company) {
      res.status(404).json({
        success: false,
        error: 'Company not found'
      })
      return
    }

    // Determine reference type and IBAN based on invoice reference
    const { referenceType, iban } = getReferenceTypeAndIban(invoice.qr_reference, company)

    // Generate Swiss QR-Invoice data according to SIX standard
    const qrData = {
      // QR Type
      qrType: 'SPC', // Swiss Payments Code
      version: '0200', // Version 2.0
      codingType: '1', // UTF-8
      
      // Account (Creditor) - use correct IBAN based on reference type
      iban: iban,
      creditor: {
        addressType: 'S', // Structured address
        name: company.name,
        street: company.address,
        houseNumber: '', // Could be extracted from address
        postalCode: company.zip,
        town: company.city,
        country: company.country || 'CH'
      },
      
      // Amount
      amount: (invoice.total / 100).toFixed(2), // Convert from Rappen to CHF
      currency: 'CHF',
      
      // Debtor (Customer)
      debtor: {
        addressType: 'S',
        name: invoice.customers.name,
        street: invoice.customers.address,
        houseNumber: '',
        postalCode: invoice.customers.zip,
        town: invoice.customers.city,
        country: invoice.customers.country || 'CH'
      },
      
      // Payment reference
      referenceType: referenceType, // QRR for QR-IBAN, SCOR for normal IBAN
      reference: invoice.qr_reference,
      
      // Additional information
      unstructuredMessage: `Invoice ${invoice.number}`,
      trailer: 'EPD', // End Payment Data
      
      // For display
      invoiceNumber: invoice.number,
      invoiceDate: invoice.date,
      dueDate: invoice.due_date,
      
      // QR Code payload (simplified - in production use proper QR lib)
      qrCodePayload: [
        'SPC', // QR Type
        '0200', // Version
        '1', // Coding
        iban, // IBAN (QR-IBAN for QRR, normal IBAN for SCOR)
        'S', // Address type
        company.name, // Creditor name
        company.address, // Street
        '', // House number
        company.zip, // Postal code
        company.city, // Town
        'CH', // Country
        '', '', '', '', '', '', '', // Ultimate creditor (empty)
        (invoice.total / 100).toFixed(2), // Amount (convert from Rappen)
        'CHF', // Currency
        'S', // Debtor address type
        invoice.customers.name, // Debtor name
        invoice.customers.address, // Debtor street
        '', // Debtor house number
        invoice.customers.zip, // Debtor postal code
        invoice.customers.city, // Debtor town
        invoice.customers.country || 'CH', // Debtor country
        referenceType, // Reference type (QRR or SCOR)
        invoice.qr_reference, // Reference
        `Invoice ${invoice.number}`, // Additional info
        'EPD' // Trailer
      ].join('\n')
    }

    res.json({
      success: true,
      data: qrData
    })

  } catch (error) {
    handleSupabaseError(error, 'generate QR code')
  }
})

/**
 * @desc    Generate invoice PDF
 * @route   GET /api/v1/invoices/:id/pdf
 * @access  Private
 */
export const generateInvoicePdf = asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
  const companyId = req.user?.companyId
  const invoiceId = req.params.id

  if (!companyId) {
    res.status(401).json({
      success: false,
      error: 'Authentication required'
    })
    return
  }

  try {
    // Get invoice with all related data
    const { data: invoice, error: invoiceError } = await db.invoices()
      .select(`
        *,
        customers (
          id, name, company, address, zip, city, country, email, phone, uid, vat_number
        ),
        invoice_items (
          id, description, quantity, unit, unit_price, discount, vat_rate, line_total, vat_amount, sort_order
        )
      `)
      .eq('id', invoiceId)
      .eq('company_id', companyId)
      .single()

    if (invoiceError || !invoice) {
      res.status(404).json({
        success: false,
        error: 'Invoice not found'
      })
      return
    }

    // Get company data
    const { data: company, error: companyError } = await db.companies()
      .select('*')
      .eq('id', companyId)
      .single()

    if (companyError || !company) {
      res.status(404).json({
        success: false,
        error: 'Company not found'
      })
      return
    }

    // Fetch and convert logo to base64 if available
    let logoBase64 = null
    if (company.logo_url) {
      try {
        console.log('üîç Attempting to fetch logo for PDF. Logo URL:', company.logo_url)
        
        // Extract path from logo URL - handle different URL formats
        let logoPath = null
        if (company.logo_url.includes('/storage/v1/object/public/logos/')) {
          logoPath = company.logo_url.split('/storage/v1/object/public/logos/')[1].split('?')[0] // Remove query params if any
        } else if (company.logo_url.includes('/logos/')) {
          logoPath = company.logo_url.split('/logos/')[1].split('?')[0]
        } else if (company.logo_url.startsWith('logos/')) {
          logoPath = company.logo_url.replace('logos/', '').split('?')[0]
        } else {
          // If it's just a path without the full URL, use it directly
          logoPath = company.logo_url.split('?')[0]
        }
        
        console.log('üìÇ Extracted logo path:', logoPath)
        
        if (logoPath) {
          // Download logo from Supabase Storage
          const { data: logoData, error: logoError } = await supabaseAdmin.storage
            .from('logos')
            .download(logoPath)
          
          if (logoError) {
            console.error('‚ùå Error downloading logo from storage:', logoError)
          } else if (logoData) {
            // Convert to base64
            const logoBuffer = Buffer.from(await logoData.arrayBuffer())
            const logoMimeType = logoData.type || 'image/png'
            logoBase64 = `data:${logoMimeType};base64,${logoBuffer.toString('base64')}`
            console.log('‚úÖ Logo converted to base64 for PDF. Size:', logoBuffer.length, 'bytes')
          } else {
            console.warn('‚ö†Ô∏è Logo data is null/undefined')
          }
        } else {
          console.warn('‚ö†Ô∏è Could not extract logo path from URL:', company.logo_url)
        }
      } catch (logoFetchError) {
        console.error('‚ùå Error fetching logo for PDF:', logoFetchError)
        // Continue without logo if fetch fails
      }
    } else {
      console.log('‚ÑπÔ∏è No logo_url found in company data')
    }

    // Determine reference type and IBAN based on invoice reference
    const { referenceType, iban } = getReferenceTypeAndIban(invoice.qr_reference, company)

    // Generate Swiss QR code according to SIX standard
    const QRCode = require('qrcode')
    
    const paymentReference = invoice.qr_reference
    
    // Swiss QR-Invoice payload according to SIX standard
    const qrPayload = [
      'SPC', // Swiss Payments Code
      '0200', // Version
      '1', // Coding (UTF-8)
      iban, // IBAN (QR-IBAN for QRR, normal IBAN for SCOR)
      'S', // Creditor address type (Structured)
      company.name, // Creditor name
      company.address, // Creditor street
      '', // Creditor house number
      company.zip, // Creditor postal code
      company.city, // Creditor town
      'CH', // Creditor country
      '', '', '', '', '', '', '', // Ultimate creditor (empty)
      (invoice.total / 100).toFixed(2), // Amount (convert from Rappen)
      'CHF', // Currency
      'S', // Debtor address type
      invoice.customers.name, // Debtor name
      invoice.customers.address, // Debtor street
      '', // Debtor house number
      invoice.customers.zip, // Debtor postal code
      invoice.customers.city, // Debtor town
      invoice.customers.country || 'CH', // Debtor country
      referenceType, // Reference type (QRR for QR-IBAN, SCOR for normal IBAN)
      paymentReference, // Payment reference
      `Invoice ${invoice.number}`, // Additional information
      'EPD' // End Payment Data
    ].join('\n')
    
    // Generate QR code as base64 image
    const qrCodeImage = await QRCode.toDataURL(qrPayload, {
      type: 'image/png',
      width: 140,
      margin: 1,
      color: {
        dark: '#000000',
        light: '#FFFFFF'
      }
    })
    
    console.log('QR code generated for invoice:', invoice.number)

    // Use unified PDF template
    const htmlTemplate = generateUnifiedInvoicePdfTemplate({
      invoice: {
        number: invoice.number,
        date: invoice.date,
        due_date: invoice.due_date,
        service_date: invoice.service_date,
        qr_reference: invoice.qr_reference,
        subtotal: invoice.subtotal,
        discount_amount: invoice.discount_amount,
        vat_amount: invoice.vat_amount,
        total: invoice.total,
        invoice_items: invoice.invoice_items || []
      },
      customer: {
        name: invoice.customers.name,
        company: invoice.customers.company,
        address: invoice.customers.address,
        zip: invoice.customers.zip,
        city: invoice.customers.city,
        country: invoice.customers.country,
        email: invoice.customers.email,
        phone: invoice.customers.phone,
        payment_terms: invoice.customers.payment_terms
      },
      company: {
        name: company.name,
        address: company.address,
        zip: company.zip,
        city: company.city,
        email: company.email,
        phone: company.phone,
        uid: company.uid,
        vat_number: company.vat_number,
        iban: company.iban,
        qr_iban: company.qr_iban,
        website: company.website
      },
      qrCodeImage,
      logoBase64,
      paymentReference,
      referenceType,
      iban
    })

    // Generate actual PDF using html-pdf-node
    try {
      const htmlPdf = require('html-pdf-node')
      
      console.log('Starting PDF generation for invoice:', invoice.number)
      
      const options = {
        format: 'A4',
        margin: {
          top: '20mm',
          bottom: '20mm',
          left: '20mm',
          right: '20mm'
        },
        printBackground: true,
        displayHeaderFooter: false,
        timeout: 30000,
        preferCSSPageSize: true,
        emulateMedia: 'print',
        args: [
          '--no-sandbox', 
          '--disable-setuid-sandbox',
          '--disable-dev-shm-usage',
          '--disable-gpu',
          '--run-all-compositor-stages-before-draw'
        ]
      }
      
      const file = { content: htmlTemplate }
      
      console.log('Generating PDF with html-pdf-node...')
      
      const pdfBuffer = await htmlPdf.generatePdf(file, options)
      
      console.log('PDF generated successfully, size:', pdfBuffer.length)
      
      // Send PDF as download
      res.setHeader('Content-Type', 'application/pdf')
      res.setHeader('Content-Disposition', `attachment; filename="Invoice-${invoice.number}.pdf"`)
      res.setHeader('Content-Length', pdfBuffer.length.toString())
      res.send(pdfBuffer)
      
    } catch (pdfError: any) {
      console.error('PDF generation error:', pdfError)
      
      // Fallback to HTML if PDF fails
      res.setHeader('Content-Type', 'text/html; charset=utf-8')
      res.send(htmlTemplate + `
        <br><br>
        <div style="color: red; background: #ffe6e6; padding: 10px; border: 1px solid red; margin: 20px;">
          <strong>PDF Generation Failed:</strong> ${pdfError?.message || 'Unknown error'}<br>
          Showing HTML version instead. Use browser Print ‚Üí Save as PDF.
        </div>
      `)
    }

  } catch (error) {
    handleSupabaseError(error, 'generate PDF')
  }
})

/**
 * @desc    Send reminder for invoice
 * @route   POST /api/v1/invoices/:id/reminder
 * @access  Private
 */
export const sendInvoiceReminder = asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
  const companyId = req.user?.companyId
  const invoiceId = req.params.id
  const { level } = req.body

  console.log('üìß Reminder request:', { companyId, invoiceId, level })

  if (!companyId) {
    res.status(401).json({
      success: false,
      error: 'Authentication required'
    })
    return
  }

  try {
    // Get invoice with customer and company data
    console.log('üîç Looking up invoice:', { invoiceId, companyId })
    const { data: invoice, error: invoiceError } = await db.invoices()
      .select(`
        *,
        customers (
          id, name, company, email, address, zip, city, country, phone
        )
      `)
      .eq('id', invoiceId)
      .eq('company_id', companyId)
      .single()
    
    // Get company data for PDF
    const { data: company, error: companyError } = await db.companies()
      .select('*')
      .eq('id', companyId)
      .single()
    
    if (companyError || !company) {
      res.status(404).json({
        success: false,
        error: 'Company not found'
      })
      return
    }

    console.log('üìã Invoice lookup result:', { invoice, error: invoiceError })

    if (invoiceError || !invoice) {
      console.log('‚ùå Invoice not found:', invoiceError)
      res.status(404).json({
        success: false,
        error: 'Invoice not found'
      })
      return
    }

    // Check if invoice is eligible for reminders
    console.log('üìä Invoice status:', invoice.status)
    if (invoice.status === 'CANCELLED') {
      console.log('‚ùå Invoice is cancelled, cannot send reminder')
      res.status(400).json({
        success: false,
        error: 'Cannot send reminder for cancelled invoice'
      })
      return
    }
    
    // Check if invoice is fully paid
    const totalAmount = invoice.total
    const paidAmount = invoice.paid_amount || 0
    const isFullyPaid = paidAmount >= totalAmount
    
    if (isFullyPaid) {
      console.log('‚ùå Invoice is fully paid, cannot send reminder')
      res.status(400).json({
        success: false,
        error: 'Cannot send reminder for fully paid invoice'
      })
      return
    }
    
    // Check if 1 day has passed since due date (reminder can be sent on the day after due date)
    const dueDate = new Date(invoice.due_date)
    // Set time to start of day for accurate day calculation
    dueDate.setHours(0, 0, 0, 0)
    const today = new Date()
    today.setHours(0, 0, 0, 0)
    const daysSinceDue = Math.floor((today.getTime() - dueDate.getTime()) / (1000 * 60 * 60 * 24))
    
    if (daysSinceDue < 1) {
      if (daysSinceDue < 0) {
        const daysUntilDue = Math.abs(daysSinceDue)
        console.log(`‚ùå Due date hasn't passed yet. ${daysUntilDue} days until due date.`)
        res.status(400).json({
          success: false,
          error: `Reminder can only be sent after the due date has passed. Due date is in ${daysUntilDue + 1} ${daysUntilDue === 0 ? 'day' : 'days'}.`
        })
      } else {
        console.log(`‚ùå Due date is today. Reminder can be sent tomorrow.`)
        res.status(400).json({
          success: false,
          error: `Reminder can be sent starting 1 day after the due date. Please try again tomorrow.`
        })
      }
      return
    }
    
    console.log(`‚úÖ Invoice eligible for reminder: ${daysSinceDue} days overdue, CHF ${((totalAmount - paidAmount) / 100).toFixed(2)} remaining`)

    // Check if reminder level is valid
    if (level < 1 || level > 3) {
      res.status(400).json({
        success: false,
        error: 'Invalid reminder level (must be 1-3)'
      })
      return
    }
    
    // For testing purposes, allow any level (remove strict validation)
    console.log(`Sending reminder level ${level} for invoice ${invoice.number}`)

    // Cooldown check is now handled above with 1-hour testing period

    // Generate professional reminder PDF using new template
    let pdfFilePath: string | null = null
    let pdfBuffer: Buffer | null = null
    try {
      console.log(`üé® Generating professional reminder PDF (Level ${level}) for invoice: ${invoice.number}`)
      
      // Fetch and convert logo to base64 if available
      let logoBase64 = null
      if (company.logo_url) {
        try {
          let logoPath = null
          if (company.logo_url.includes('/storage/v1/object/public/logos/')) {
            logoPath = company.logo_url.split('/storage/v1/object/public/logos/')[1].split('?')[0]
          } else if (company.logo_url.includes('/logos/')) {
            logoPath = company.logo_url.split('/logos/')[1].split('?')[0]
          } else if (company.logo_url.startsWith('logos/')) {
            logoPath = company.logo_url.replace('logos/', '').split('?')[0]
          } else {
            logoPath = company.logo_url.split('?')[0]
          }
          
          if (logoPath) {
            const { data: logoData, error: logoError } = await supabaseAdmin.storage
              .from('logos')
              .download(logoPath)
            
            if (logoError) {
              console.error('‚ùå Error downloading logo for reminder:', logoError)
            } else if (logoData) {
              const logoBuffer = Buffer.from(await logoData.arrayBuffer())
              const logoMimeType = logoData.type || 'image/png'
              logoBase64 = `data:${logoMimeType};base64,${logoBuffer.toString('base64')}`
              console.log('‚úÖ Logo converted to base64 for reminder')
            }
          }
        } catch (logoFetchError) {
          console.error('‚ùå Error fetching logo for reminder:', logoFetchError)
        }
      }
      
      // Calculate reminder fees and days overdue
      const reminderFees = { 1: 0, 2: 20.00, 3: 50.00 }
      const reminderFee = reminderFees[level as keyof typeof reminderFees]
      const daysSinceDue = Math.floor((new Date().getTime() - new Date(invoice.due_date).getTime()) / (1000 * 60 * 60 * 24))
      
      // Determine reference type and IBAN based on invoice reference
      const { referenceType, iban } = getReferenceTypeAndIban(invoice.qr_reference, company)
      
      // Calculate total amount with fee
      const remainingAmount = invoice.total - (invoice.paid_amount || 0)
      const totalWithFee = remainingAmount + (reminderFee * 100) // Fee in Rappen
      
      // Generate QR code for payment (using total amount including fee)
      const QRCode = require('qrcode')
      const qrPayload = [
        'SPC', // Swiss Payments Code
        '0200', // Version
        '1', // Coding type (1 = UTF-8)
        iban || '', // IBAN
        'K', // Creditor address type (K = structured)
        company.name || '',
        company.address || '',
        company.zip || '',
        company.city || '',
        company.country || 'CH',
        '', '', '', '', '', '', '', // Empty creditor fields
        (totalWithFee / 100).toFixed(2), // Amount with fee
        'CHF', // Currency
        'K', // Debtor address type (K = structured)
        invoice.customers.name || '',
        invoice.customers.address || '',
        invoice.customers.zip || '',
        invoice.customers.city || '',
        invoice.customers.country || 'CH',
        '', '', '', '', '', '', '', // Empty debtor fields
        referenceType, // Reference type
        invoice.qr_reference || '', // Payment reference
        `Mahnung ${level} - Rechnung ${invoice.number}`, // Additional information
        'EPD' // End Payment Data
      ].join('\r\n')
      
      const qrCodeImage = await QRCode.toDataURL(qrPayload, {
        errorCorrectionLevel: 'M',
        type: 'image/png',
        width: 300,
        margin: 1
      })
      
      // Generate HTML using professional template
      const htmlTemplate = generateReminderPdfTemplate({
        invoice: {
          number: invoice.number,
          date: invoice.date,
          due_date: invoice.due_date,
          service_date: invoice.service_date,
          qr_reference: invoice.qr_reference,
          subtotal: invoice.subtotal,
          vat_amount: invoice.vat_amount,
          total: invoice.total,
          paid_amount: invoice.paid_amount || 0
        },
        customer: {
          name: invoice.customers.name,
          company: invoice.customers.company,
          address: invoice.customers.address,
          zip: invoice.customers.zip,
          city: invoice.customers.city,
          country: invoice.customers.country,
          email: invoice.customers.email,
          phone: invoice.customers.phone
        },
        company: {
          name: company.name,
          address: company.address,
          zip: company.zip,
          city: company.city,
          email: company.email,
          phone: company.phone,
          uid: company.uid,
          vat_number: company.vat_number,
          iban: company.iban,
          qr_iban: company.qr_iban,
          website: company.website
        },
        qrCodeImage,
        logoBase64,
        paymentReference: invoice.qr_reference,
        referenceType: referenceType as 'QRR' | 'SCOR',
        iban: iban || company.iban || '',
        reminderLevel: level as 1 | 2 | 3,
        reminderFee,
        daysOverdue: daysSinceDue
      })
      
      // Generate PDF with html-pdf-node
      const htmlPdf = require('html-pdf-node')
      const options = {
        format: 'A4',
        margin: { top: '0', bottom: '0', left: '0', right: '0' }, // Let CSS handle margins
        printBackground: true,
        displayHeaderFooter: false,
        timeout: 30000,
        preferCSSPageSize: true,
        emulateMedia: 'print',
        args: [
          '--no-sandbox',
          '--disable-setuid-sandbox',
          '--disable-dev-shm-usage',
          '--disable-gpu',
          '--run-all-compositor-stages-before-draw'
        ]
      }
      
      const file = { content: htmlTemplate }
      console.log(`üìÑ Generating PDF for reminder level ${level}...`)
      pdfBuffer = await htmlPdf.generatePdf(file, options)
      console.log(`‚úÖ PDF generated: ${pdfBuffer.length} bytes`)
      
      
      // Create organized file path for storage
          body { 
            font-family: Arial, sans-serif; 
            margin: 0; 
            padding: 0; 
            font-size: 12px;
            line-height: 1.4;
            color: #333;
          }
          .page-break {
            page-break-before: always;
          }
          .no-break {
            page-break-inside: avoid;
          }
          .header { 
            display: flex; 
            justify-content: space-between; 
            align-items: start;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e5e5e5;
            page-break-inside: avoid;
          }
          .reminder-title { 
            font-size: 20px; 
            font-weight: bold; 
            color: #2563eb;
            margin: 20px 0 15px 0;
            text-align: center;
            text-transform: uppercase;
            page-break-inside: avoid;
          }
          .customer-address {
            margin: 30px 0;
            line-height: 1.3;
          }
          .reminder-content {
            margin: 25px 0;
            line-height: 1.6;
            page-break-inside: avoid;
          }
          .invoice-details {
            margin: 25px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-left: 4px solid #2563eb;
            page-break-inside: avoid;
          }
          .payment-progress {
            margin: 25px 0;
            padding: 15px;
            background-color: #f0f9ff;
            border: 1px solid #0ea5e9;
            border-radius: 8px;
            page-break-inside: avoid;
          }
          .progress-bar-container {
            width: 100%;
            height: 30px;
            background-color: #e5e7eb;
            border-radius: 15px;
            overflow: hidden;
            margin: 15px 0;
            position: relative;
          }
          .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981 0%, #059669 100%);
            border-radius: 15px;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 12px;
          }
          .progress-info {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 11px;
            color: #6b7280;
          }
          .payment-info {
            margin: 25px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            page-break-inside: avoid;
          }
        </style>
      </head>
      <body>
        <!-- Header -->
        <div class="header">
          <div>
            <h1>${company.name}</h1>
            <div>${company.address}</div>
            <div>${company.zip} ${company.city}</div>
            <div>Schweiz</div>
          </div>
        </div>

        <!-- Customer Address -->
        <div class="customer-address">
          <strong>${invoice.customers.name}</strong><br>
          ${invoice.customers.company ? `${invoice.customers.company}<br>` : ''}
          ${invoice.customers.address}<br>
          ${invoice.customers.zip} ${invoice.customers.city}
        </div>

        <!-- Date -->
        <div style="text-align: right; margin: 20px 0;">
          ${company.city}, ${new Date().toLocaleDateString('de-CH')}
        </div>

        <!-- Reminder Title -->
        <div class="reminder-title">${template.title}</div>

        <!-- Reminder Content -->
        <div class="reminder-content">
          <p>Sehr geehrte Damen und Herren,</p>
          <p>${template.body}</p>
          <p>Sollten Sie die Zahlung bereits veranlasst haben, betrachten Sie dieses Schreiben als gegenstandslos.</p>
        </div>

        <!-- Invoice Details -->
        <div class="invoice-details">
          <h3 style="margin-top: 0;">Rechnungsdetails</h3>
          <table style="width: 100%; border-collapse: collapse;">
            <tr>
              <td style="padding: 8px 0;"><strong>Rechnungsnummer:</strong></td>
              <td style="padding: 8px 0;">${invoice.number}</td>
            </tr>
            <tr>
              <td style="padding: 8px 0;"><strong>Rechnungsdatum:</strong></td>
              <td style="padding: 8px 0;">${new Date(invoice.date).toLocaleDateString('de-CH')}</td>
            </tr>
            <tr>
              <td style="padding: 8px 0;"><strong>F√§lligkeitsdatum:</strong></td>
              <td style="padding: 8px 0;">${new Date(invoice.due_date).toLocaleDateString('de-CH')}</td>
            </tr>
            <tr>
              <td style="padding: 8px 0;"><strong>Tage √ºberf√§llig:</strong></td>
              <td style="padding: 8px 0; color: red; font-weight: bold;">${daysSinceDue} Tage</td>
            </tr>
            <tr>
              <td style="padding: 8px 0;"><strong>Rechnungsbetrag:</strong></td>
              <td style="padding: 8px 0; font-weight: bold;">CHF ${totalAmountCHF.toFixed(2)}</td>
            </tr>
          </table>
        </div>

        <!-- Payment Progress -->
        <div class="payment-progress">
          <h3 style="margin-top: 0;">Zahlungsstatus</h3>
          <div class="progress-bar-container">
            <div class="progress-bar-fill" style="width: ${Math.min(paymentProgress, 100)}%;">
              ${paymentProgress.toFixed(1)}%
            </div>
          </div>
          <div class="progress-info">
            <span>Bezahlt: <strong>CHF ${paidAmountCHF.toFixed(2)}</strong></span>
            <span>Offen: <strong>CHF ${remainingAmountCHF.toFixed(2)}</strong></span>
          </div>
          <div style="margin-top: 15px; text-align: center; font-weight: bold; color: #dc2626;">
            Offener Betrag: CHF ${remainingAmountCHF.toFixed(2)}
          </div>
        </div>

        <!-- Payment Information -->
        <div class="payment-info">
          <h3>Zahlungsinformationen</h3>
          <p><strong>Zahlbar bis:</strong> ${new Date(Date.now() + (level === 3 ? 3 : level === 2 ? 5 : 10) * 24 * 60 * 60 * 1000).toLocaleDateString('de-CH')}</p>
          <p><strong>Referenz:</strong> ${invoice.qr_reference}</p>
          <p>Bitte verwenden Sie den beigef√ºgten QR-Code f√ºr die Zahlung oder √ºberweisen Sie den Betrag unter Angabe der Referenznummer.</p>
        </div>

        <!-- Page Break Before QR Section -->
        <div style="page-break-before: always;"></div>
        
        <!-- Swiss QR-Invoice Payment Slip (Separate Page) -->
        <div style="width: 210mm; height: 297mm; position: relative; margin: 0; padding: 0;">
          
          <!-- QR-Invoice Header -->
          <div style="text-align: center; margin: 20mm 0 10mm 0; font-size: 16px; font-weight: bold;">
            Zahlteil / Section paiement / Sezione pagamento
          </div>
          
          <!-- Main QR Payment Section -->
          <div style="display: flex; height: 105mm; border: 1px solid #000;">
            
            <!-- Receipt Section (Left) -->
            <div style="width: 62mm; padding: 5mm; border-right: 1px solid #000; font-size: 8pt; position: relative;">
              <div style="font-weight: bold; margin-bottom: 5mm;">Empfangsschein</div>
              
              <div style="margin-bottom: 3mm;">
                <div style="font-weight: bold; font-size: 6pt;">Konto / Payable to</div>
                <div>${company.iban || 'CH21 0900 0000 1001 5000 6'}</div>
                <div>${company.name}</div>
                <div>${company.address}</div>
                <div>${company.zip} ${company.city}</div>
              </div>
              
              <div style="margin-bottom: 3mm;">
                <div style="font-weight: bold; font-size: 6pt;">Referenz</div>
                <div style="font-size: 8pt;">${invoice.qr_reference}</div>
              </div>
              
              <div style="margin-bottom: 3mm;">
                <div style="font-weight: bold; font-size: 6pt;">Zahlbar durch</div>
                <div>${invoice.customers.name}</div>
                ${invoice.customers.company ? `<div>${invoice.customers.company}</div>` : ''}
                <div>${invoice.customers.address}</div>
                <div>${invoice.customers.zip} ${invoice.customers.city}</div>
              </div>
              
              <div style="position: absolute; bottom: 5mm; left: 5mm;">
                <div style="font-weight: bold; font-size: 6pt;">W√§hrung</div>
                <div>CHF</div>
              </div>
              
              <div style="position: absolute; bottom: 5mm; left: 20mm;">
                <div style="font-weight: bold; font-size: 6pt;">Betrag</div>
                <div style="font-weight: bold;">${remainingAmountCHF.toFixed(2)}</div>
              </div>
              
              <div style="position: absolute; bottom: 15mm; right: 5mm; font-size: 6pt;">
                Annahmestelle
              </div>
            </div>
            
            <!-- Payment Section (Right) -->
            <div style="flex: 1; padding: 5mm; position: relative;">
              <div style="font-weight: bold; margin-bottom: 5mm;">Zahlteil</div>
              
              <!-- QR Code -->
              <div style="position: absolute; top: 5mm; right: 5mm;">
                <img src="${qrCodeImage}" alt="Swiss QR Code" style="width: 46mm; height: 46mm;" />
                <div style="text-align: center; margin-top: 2mm; font-size: 6pt;">
                  üá®üá≠ Swiss QR Code
                </div>
              </div>
              
              <!-- Payment Information -->
              <div style="width: 55mm;">
                <div style="margin-bottom: 3mm;">
                  <div style="font-weight: bold; font-size: 6pt;">W√§hrung</div>
                  <div>CHF</div>
                </div>
                
                <div style="margin-bottom: 3mm;">
                  <div style="font-weight: bold; font-size: 6pt;">Betrag</div>
                  <div style="font-weight: bold; font-size: 10pt;">${remainingAmountCHF.toFixed(2)}</div>
                </div>
                
                <div style="margin-bottom: 3mm;">
                  <div style="font-weight: bold; font-size: 6pt;">Konto / Payable to</div>
                  <div>${company.iban || 'CH21 0900 0000 1001 5000 6'}</div>
                  <div>${company.name}</div>
                  <div>${company.address}</div>
                  <div>${company.zip} ${company.city}</div>
                </div>
                
                <div style="margin-bottom: 3mm;">
                  <div style="font-weight: bold; font-size: 6pt;">Referenz</div>
                  <div style="font-size: 8pt; word-break: break-all;">${invoice.qr_reference}</div>
                </div>
                
                <div style="margin-bottom: 3mm;">
                  <div style="font-weight: bold; font-size: 6pt;">Zus√§tzliche Informationen</div>
                  <div style="font-size: 8pt;">Rechnung ${invoice.number}</div>
                  <div style="font-size: 8pt;">${template.title}</div>
                  <div style="font-size: 8pt;">Zahlbar bis: ${new Date(Date.now() + (level === 3 ? 3 : level === 2 ? 5 : 10) * 24 * 60 * 60 * 1000).toLocaleDateString('de-CH')}</div>
                </div>
                
                <div>
                  <div style="font-weight: bold; font-size: 6pt;">Zahlbar durch</div>
                  <div>${invoice.customers.name}</div>
                  ${invoice.customers.company ? `<div>${invoice.customers.company}</div>` : ''}
                  <div>${invoice.customers.address}</div>
                  <div>${invoice.customers.zip} ${invoice.customers.city}</div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Perforated Line -->
          <div style="margin: 5mm 0; border-top: 1px dashed #000; text-align: center; font-size: 6pt; color: #666;">
            ‚úÇÔ∏è Hier abtrennen / D√©tacher ici / Staccare qui
          </div>
          
        </div>

        <!-- Closing -->
        <div style="margin: 40px 0 20px 0;">
          <p>Freundliche Gr√ºsse</p>
          <br>
          <p><strong>${company.name}</strong></p>
        </div>
      </body>
      </html>
      `
      
      const options = {
        format: 'A4',
        margin: {
          top: '20mm',
          bottom: '20mm',
          left: '20mm',
          right: '20mm'
        },
        printBackground: true,
        timeout: 30000
      }
      
      const file = { content: htmlTemplate }
      pdfBuffer = await htmlPdf.generatePdf(file, options)
      
      // Create organized file path: CompanyName/CustomerName/InvoiceNumber/filename.pdf
      // Sanitize names for file paths (remove special characters, spaces become underscores)
      const sanitizeForPath = (name: string) => {
        return name.replace(/[^a-zA-Z0-9-_]/g, '_').replace(/_+/g, '_').replace(/^_|_$/g, '')
      }
      
      const companyName = sanitizeForPath(company.name || 'Company')
      const customerName = sanitizeForPath(invoice.customers.name || 'Customer')
      const invoiceNumber = sanitizeForPath(invoice.number)
      
      const fileName = `Reminder-${level}-${invoice.number}.pdf`
      const filePath = `${companyName}/${customerName}/${invoiceNumber}/${fileName}`
      
      if (!pdfBuffer) {
        throw new Error('Failed to generate PDF buffer')
      }

      const { data: uploadData, error: uploadError } = await supabaseAdmin.storage
        .from('invoices')
        .upload(filePath, pdfBuffer, {
          contentType: 'application/pdf',
          upsert: false
        })
      
      if (uploadError) {
        console.error('‚ùå Failed to upload reminder PDF to storage:', uploadError)
      } else {
        pdfFilePath = uploadData.path
        console.log('‚úÖ Reminder PDF uploaded successfully:', pdfFilePath)
        
        // Store file reference in database - we'll use a simple JSON structure in internal_notes
        // TODO: Create invoice_files table for proper file management
        const fileInfo = {
          id: crypto.randomUUID(),
          fileName: fileName,
          filePath: uploadData.path,
          fileType: 'reminder_pdf',
          reminderLevel: level,
          uploadedAt: new Date().toISOString()
        }
        
        // Update invoice with file info (store in internal_notes as JSON for now)
        const currentNotes = invoice.internal_notes || '{}'
        let notesData: any = {}
        try {
          // If notes is not empty and is JSON, parse it
          if (currentNotes && currentNotes.trim() !== '' && currentNotes.trim().startsWith('{')) {
            notesData = JSON.parse(currentNotes)
          }
        } catch (e) {
          // If not JSON, create new structure and preserve old notes as text
          notesData = {
            _oldNotes: currentNotes,
            files: []
          }
        }
        
        if (!notesData.files) {
          notesData.files = []
        }
        notesData.files.push(fileInfo)
        
        await db.invoices()
          .update({
            internal_notes: JSON.stringify(notesData)
          })
          .eq('id', invoiceId)
      }
    } catch (pdfError: any) {
      console.error('‚ùå Error generating reminder PDF:', pdfError)
      // Continue without PDF - email will still be sent
    }

    // Update invoice reminder level and timestamp
    const { data: updatedInvoice, error: updateError } = await db.invoices()
      .update({
        reminder_level: level,
        last_reminder_at: new Date().toISOString(),
        email_sent_count: (invoice.email_sent_count || 0) + 1
      })
      .eq('id', invoiceId)
      .eq('company_id', companyId)
      .select()
      .single()

    if (updateError) {
      handleSupabaseError(updateError, 'update reminder level')
      return
    }

    // Send actual email using Resend to verified email
    try {
      const { Resend } = require('resend')
      const resend = new Resend(process.env.RESEND_API_KEY)
      
      // Send to verified email address
      const verifiedEmail = 'mkrshkov@gmail.com'
      
      const daysSinceDue = Math.floor((new Date().getTime() - new Date(invoice.due_date).getTime()) / (1000 * 60 * 60 * 24))
      const totalAmountCHF = invoice.total / 100
      const paidAmountCHF = (invoice.paid_amount || 0) / 100
      const remainingAmountCHF = totalAmountCHF - paidAmountCHF
      
      const emailData: any = {
        from: `${config.email.fromName} <${config.email.fromEmail}>`,
        to: [verifiedEmail],
        subject: `${level}. Mahnung - Rechnung ${invoice.number}`,
        html: `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <title>Payment Reminder</title>
          </head>
          <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;">
            <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
              <h2 style="color: #2563eb; margin: 0;">${level}. Mahnung - Rechnung ${invoice.number}</h2>
            </div>
            
            <p>Sehr geehrte Damen und Herren,</p>
            
            <p>Es sind bereits ${daysSinceDue} Tage seit dem F√§lligkeitsdatum vergangen, und wir haben noch keine vollst√§ndige Zahlung erhalten.</p>
            
            <div style="background: #f1f5f9; padding: 15px; border-radius: 6px; margin: 20px 0;">
              <p><strong>Rechnungsnummer:</strong> ${invoice.number}</p>
              <p><strong>Rechnungsdatum:</strong> ${new Date(invoice.date).toLocaleDateString('de-CH')}</p>
              <p><strong>F√§lligkeitsdatum:</strong> ${new Date(invoice.due_date).toLocaleDateString('de-CH')}</p>
              <p><strong>Rechnungsbetrag:</strong> CHF ${totalAmountCHF.toFixed(2)}</p>
              <p><strong>Bezahlt:</strong> CHF ${paidAmountCHF.toFixed(2)}</p>
              <p><strong>Offener Betrag:</strong> <strong style="color: #dc2626;">CHF ${remainingAmountCHF.toFixed(2)}</strong></p>
            </div>
            
            <p>Bitte sehen Sie die beigef√ºgte PDF-Datei f√ºr weitere Details.</p>
            
            <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e5e7eb;">
              <p>Freundliche Gr√ºsse<br><strong>${company.name}</strong></p>
              <p style="font-size: 12px; color: #6b7280;">
                Test email sent to ${verifiedEmail}
              </p>
            </div>
          </body>
          </html>
        `,
        text: `${level}. Mahnung - Rechnung ${invoice.number}\n\nSehr geehrte Damen und Herren,\n\nEs sind bereits ${daysSinceDue} Tage seit dem F√§lligkeitsdatum vergangen, und wir haben noch keine vollst√§ndige Zahlung erhalten.\n\nRechnungsnummer: ${invoice.number}\nRechnungsdatum: ${new Date(invoice.date).toLocaleDateString('de-CH')}\nF√§lligkeitsdatum: ${new Date(invoice.due_date).toLocaleDateString('de-CH')}\nOffener Betrag: CHF ${remainingAmountCHF.toFixed(2)}\n\nBitte sehen Sie die beigef√ºgte PDF-Datei f√ºr weitere Details.\n\nFreundliche Gr√ºsse\n${company.name}\n\nTest email sent to ${verifiedEmail}`
      }
      
      // Add PDF attachment if available
      if (pdfBuffer && Buffer.isBuffer(pdfBuffer)) {
        emailData.attachments = [{
          filename: `Mahnung-${level}-${invoice.number}.pdf`,
          content: pdfBuffer
        }]
      }
      
      const result = await resend.emails.send(emailData)

      if (result.data?.id) {
        console.log(`‚úÖ Reminder ${level} sent successfully to ${verifiedEmail} (Message ID: ${result.data.id})`)
      } else {
        console.error(`‚ùå Failed to send reminder email:`, result.error)
      }
    } catch (emailError) {
      console.error('Error sending reminder email:', emailError)
    }

    // Log audit event
    try {
      await createAuditLog(
        companyId,
        req.user!.id,
        req.user!.name,
        'INVOICE_REMINDER_SENT',
        'INVOICE',
        invoiceId,
        {
          invoiceNumber: invoice.number,
          reminderLevel: level,
          customerEmail: invoice.customers?.email,
          remainingAmount: (invoice.total - (invoice.paid_amount || 0)) / 100
        },
        req.ip,
        req.get('User-Agent')
      )
    } catch (auditError) {
      console.error('Error creating audit log:', auditError)
    }

    res.json({
      success: true,
      message: `Reminder ${level} sent successfully to mkrshkov@gmail.com`,
      data: {
        invoice: updatedInvoice,
        reminderLevel: level,
        sentTo: 'mkrshkov@gmail.com',
        sentAt: new Date().toISOString(),
        testMode: true
      }
    })

  } catch (error) {
    handleSupabaseError(error, 'send reminder')
  }
})

/**
 * @desc    Generate reminder PDF
 * @route   GET /api/v1/invoices/:id/reminder-pdf/:level
 * @access  Private
 */
export const generateReminderPdf = asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
  const companyId = req.user?.companyId
  const invoiceId = req.params.id
  const reminderLevel = parseInt(req.params.level)

  if (!companyId) {
    res.status(401).json({
      success: false,
      error: 'Authentication required'
    })
    return
  }

  if (!reminderLevel || reminderLevel < 1 || reminderLevel > 3) {
    res.status(400).json({
      success: false,
      error: 'Invalid reminder level (1-3)'
    })
    return
  }

  try {
    // Get invoice with customer and company data
    const { data: invoice, error: invoiceError } = await db.invoices()
      .select(`
        *,
        customers (
          id, name, company, address, zip, city, country, email, phone
        )
      `)
      .eq('id', invoiceId)
      .eq('company_id', companyId)
      .single()

    if (invoiceError || !invoice) {
      res.status(404).json({
        success: false,
        error: 'Invoice not found'
      })
      return
    }

    // Get company data
    const { data: company, error: companyError } = await db.companies()
      .select('*')
      .eq('id', companyId)
      .single()

    if (companyError || !company) {
      res.status(404).json({
        success: false,
        error: 'Company not found'
      })
      return
    }

    // Fetch and convert logo to base64 if available
    let logoBase64 = null
    if (company.logo_url) {
      try {
        console.log('üîç Attempting to fetch logo for reminder PDF. Logo URL:', company.logo_url)
        
        // Extract path from logo URL - handle different URL formats
        let logoPath = null
        if (company.logo_url.includes('/storage/v1/object/public/logos/')) {
          logoPath = company.logo_url.split('/storage/v1/object/public/logos/')[1].split('?')[0]
        } else if (company.logo_url.includes('/logos/')) {
          logoPath = company.logo_url.split('/logos/')[1].split('?')[0]
        } else if (company.logo_url.startsWith('logos/')) {
          logoPath = company.logo_url.replace('logos/', '').split('?')[0]
        } else {
          logoPath = company.logo_url.split('?')[0]
        }
        
        console.log('üìÇ Extracted logo path for reminder:', logoPath)
        
        if (logoPath) {
          const { data: logoData, error: logoError } = await supabaseAdmin.storage
            .from('logos')
            .download(logoPath)
          
          if (logoError) {
            console.error('‚ùå Error downloading logo for reminder:', logoError)
          } else if (logoData) {
            const logoBuffer = Buffer.from(await logoData.arrayBuffer())
            const logoMimeType = logoData.type || 'image/png'
            logoBase64 = `data:${logoMimeType};base64,${logoBuffer.toString('base64')}`
            console.log('‚úÖ Logo converted to base64 for reminder PDF')
          }
        }
      } catch (logoFetchError) {
        console.error('‚ùå Error fetching logo for reminder PDF:', logoFetchError)
      }
    }

    // Calculate reminder fees and days overdue
    const reminderFees = {
      1: 0,
      2: 20.00,
      3: 50.00
    }
    const reminderFee = reminderFees[reminderLevel as keyof typeof reminderFees]
    const daysOverdue = Math.floor((new Date().getTime() - new Date(invoice.due_date).getTime()) / (1000 * 60 * 60 * 24))
    
    // Determine reference type and IBAN based on invoice reference
    const getReferenceTypeAndIban = (qrReference: string, company: any) => {
      const referenceType = qrReference.startsWith('RF') ? 'SCOR' : 'QRR'
      const iban = referenceType === 'QRR' ? company.qr_iban : company.iban
      return { referenceType, iban }
    }
    
    const { referenceType, iban } = getReferenceTypeAndIban(invoice.qr_reference, company)
    
    // Calculate total amount with fee
    const remainingAmount = invoice.total - (invoice.paid_amount || 0)
    const totalWithFee = remainingAmount + (reminderFee * 100) // Fee in Rappen
    
    // Generate QR code for payment (using total amount including fee)
    const QRCode = require('qrcode')
    const qrPayload = [
      'SPC', // Swiss Payments Code
      '0200', // Version
      '1', // Coding type (1 = UTF-8)
      iban || '', // IBAN
      'K', // Creditor address type (K = structured)
      company.name || '',
      company.address || '',
      company.zip || '',
      company.city || '',
      company.country || 'CH',
      '', '', '', '', '', '', '', // Empty creditor fields
      (totalWithFee / 100).toFixed(2), // Amount with fee
      'CHF', // Currency
      'K', // Debtor address type (K = structured)
      invoice.customers.name || '',
      invoice.customers.address || '',
      invoice.customers.zip || '',
      invoice.customers.city || '',
      invoice.customers.country || 'CH',
      '', '', '', '', '', '', '', // Empty debtor fields
      referenceType, // Reference type
      invoice.qr_reference || '', // Payment reference
      `Mahnung ${reminderLevel} - Rechnung ${invoice.number}`, // Additional information
      'EPD' // End Payment Data
    ].join('\r\n')
    
    const qrCodeImage = await QRCode.toDataURL(qrPayload, {
      errorCorrectionLevel: 'M',
      type: 'image/png',
      width: 300,
      margin: 1
    })
    
    // Generate PDF using unified template
    const htmlTemplate = generateReminderPdfTemplate({
      invoice: {
        number: invoice.number,
        date: invoice.date,
        due_date: invoice.due_date,
        service_date: invoice.service_date,
        qr_reference: invoice.qr_reference,
        subtotal: invoice.subtotal,
        vat_amount: invoice.vat_amount,
        total: invoice.total,
        paid_amount: invoice.paid_amount || 0
      },
      customer: {
        name: invoice.customers.name,
        company: invoice.customers.company,
        address: invoice.customers.address,
        zip: invoice.customers.zip,
        city: invoice.customers.city,
        country: invoice.customers.country,
        email: invoice.customers.email,
        phone: invoice.customers.phone
      },
      company: {
        name: company.name,
        address: company.address,
        zip: company.zip,
        city: company.city,
        email: company.email,
        phone: company.phone,
        uid: company.uid,
        vat_number: company.vat_number,
        iban: company.iban,
        qr_iban: company.qr_iban,
        website: company.website
      },
      qrCodeImage,
      logoBase64,
      paymentReference: invoice.qr_reference,
      referenceType: referenceType as 'QRR' | 'SCOR',
      iban: iban || company.iban || '',
      reminderLevel: reminderLevel as 1 | 2 | 3,
      reminderFee,
      daysOverdue
    })

    // Generate PDF using html-pdf-node
    try {
      const htmlPdf = require('html-pdf-node')
      
      console.log(`Starting reminder PDF generation for invoice: ${invoice.number}, level: ${reminderLevel}`)
      
      const options = {
        format: 'A4',
        margin: { top: '0', bottom: '0', left: '0', right: '0' }, // Let CSS handle margins
        printBackground: true,
        displayHeaderFooter: false,
        timeout: 30000,
        preferCSSPageSize: true, // Respect CSS @page rules
        emulateMedia: 'print',   // Ensure print-specific CSS is applied
        args: [
          '--no-sandbox',
          '--disable-setuid-sandbox',
          '--disable-dev-shm-usage',
          '--disable-gpu',
          '--run-all-compositor-stages-before-draw'
        ]
      }
      
      const file = { content: htmlTemplate }
      
      const pdfBuffer = await htmlPdf.generatePdf(file, options)
      
      console.log('‚úÖ Reminder PDF generated successfully, size:', pdfBuffer.length)
      
      // Send PDF as download
      res.setHeader('Content-Type', 'application/pdf')
      res.setHeader('Content-Disposition', `attachment; filename="Mahnung-${reminderLevel}-${invoice.number}.pdf"`)
      res.setHeader('Content-Length', pdfBuffer.length.toString())
      res.send(pdfBuffer)
      
    } catch (pdfError: any) {
      console.error('Reminder PDF generation error:', pdfError)
      
      // Fallback to HTML
      res.setHeader('Content-Type', 'text/html; charset=utf-8')
      res.send(htmlTemplate + `
        <br><br>
        <div style="color: red; background: #ffe6e6; padding: 10px; border: 1px solid red; margin: 20px;">
          <strong>PDF Generation Failed:</strong> ${pdfError?.message || 'Unknown error'}<br>
          Showing HTML version instead.
        </div>
      `)
    }

  } catch (error) {
    handleSupabaseError(error, 'generate reminder PDF')
  }
})

/**
 * @desc    Update invoice
 * @route   PUT /api/v1/invoices/:id
 * @access  Private
 */
export const updateInvoice = asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
  const companyId = req.user?.companyId
  const invoiceId = req.params.id
  const updateData = req.body

  if (!companyId) {
    res.status(401).json({
      success: false,
      error: 'Authentication required'
    })
    return
  }

  try {
    // Check if invoice exists and belongs to company
    const { data: existingInvoice, error: invoiceError } = await db.invoices()
      .select('id, company_id')
      .eq('id', invoiceId)
      .eq('company_id', companyId)
      .single()

    if (invoiceError || !existingInvoice) {
      res.status(404).json({
        success: false,
        error: 'Invoice not found'
      })
      return
    }

    // Prepare update data
    const updateFields: any = {}
    
    if (updateData.status) {
      updateFields.status = updateData.status
    }
    
    if (updateData.customerId) {
      updateFields.customer_id = updateData.customerId
    }
    
    if (updateData.date) {
      updateFields.date = updateData.date
    }
    
    if (updateData.dueDate) {
      updateFields.due_date = updateData.dueDate
    }
    
    if (updateData.serviceDate) {
      updateFields.service_date = typeof updateData.serviceDate === 'string' 
        ? updateData.serviceDate 
        : new Date(updateData.serviceDate).toISOString().split('T')[0]
    }
    
    if (updateData.discountCode !== undefined) {
      updateFields.discount_code = updateData.discountCode
    }
    
    if (updateData.discountAmount !== undefined) {
      updateFields.discount_amount = updateData.discountAmount
    }
    
    if (updateData.internalNotes !== undefined) {
      updateFields.internal_notes = updateData.internalNotes
    }

    // Update invoice
    const { data: updatedInvoice, error: updateError } = await db.invoices()
      .update(updateFields)
      .eq('id', invoiceId)
      .eq('company_id', companyId)
      .select('*')
      .single()

    if (updateError) {
      res.status(400).json({
        success: false,
        error: 'Failed to update invoice'
      })
      return
    }

    // If items are provided, update them
    if (updateData.items && Array.isArray(updateData.items)) {
      // Delete existing items
      await db.invoiceItems()
        .delete()
        .eq('invoice_id', invoiceId)

      // Insert new items
      const itemsToInsert = updateData.items.map((item: any, index: number) => ({
        invoice_id: invoiceId,
        description: item.description,
        quantity: Math.round(item.quantity * 1000), // Convert to 3 decimal precision (1.5 = 1500)
        unit: item.unit || 'St√ºck',
        unit_price: Math.round(item.unitPrice * 100), // Convert CHF to Rappen
        discount: Math.round((item.discount || 0) * 100), // Convert to basis points
        vat_rate: Math.round(item.vatRate * 100), // Convert to basis points
        line_total: Math.round(item.quantity * item.unitPrice * (1 - (item.discount || 0) / 100) * 100), // Convert CHF to Rappen
        vat_amount: Math.round(item.quantity * item.unitPrice * (1 - (item.discount || 0) / 100) * (item.vatRate / 100) * 100), // Convert CHF to Rappen
        sort_order: index
      }))

      const { error: itemsError } = await db.invoiceItems()
        .insert(itemsToInsert)

      if (itemsError) {
        res.status(400).json({
          success: false,
          error: 'Failed to update invoice items'
        })
        return
      }

      // Recalculate totals
      const { data: items } = await db.invoiceItems()
        .select('line_total, vat_amount')
        .eq('invoice_id', invoiceId)

      const subtotal = items?.reduce((sum: number, item: any) => sum + item.line_total, 0) || 0
      const vatAmount = items?.reduce((sum: number, item: any) => sum + item.vat_amount, 0) || 0
      const total = subtotal + vatAmount - (updateData.discountAmount || 0)

      // Update totals
      await db.invoices()
        .update({
          subtotal,
          vat_amount: vatAmount,
          total
        })
        .eq('id', invoiceId)
    }

    res.json({
      success: true,
      data: {
        invoice: createInvoiceResponse(updatedInvoice)
      }
    })
  } catch (error: any) {
    console.error('Error updating invoice:', error)
    res.status(500).json({
      success: false,
      error: 'Internal server error'
    })
  }
})

/**
 * @desc    Delete invoice
 * @route   DELETE /api/v1/invoices/:id
 * @access  Private
 */
export const deleteInvoice = asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
  const { id } = req.params
  const companyId = req.user?.companyId

  if (!companyId) {
    res.status(401).json({
      success: false,
      error: 'Authentication required'
    })
    return
  }

  try {
    // First, fetch the invoice to get file information
    const { data: invoice, error: fetchError } = await db.invoices()
      .select('id, internal_notes, number')
      .eq('id', id)
      .eq('company_id', companyId)
      .single()

    if (fetchError) {
      if (fetchError.code === 'PGRST116') {
        res.status(404).json({
          success: false,
          error: 'Invoice not found'
        })
        return
      }
      handleSupabaseError(fetchError, 'fetch invoice for deletion')
      return
    }

    // Delete files from storage bucket if they exist
    if (invoice && invoice.internal_notes) {
      try {
        const notesData = JSON.parse(invoice.internal_notes)
        if (notesData && Array.isArray(notesData.files) && notesData.files.length > 0) {
          const filePaths = notesData.files
            .map((file: any) => file.filePath)
            .filter((path: string) => path) // Filter out any null/undefined paths

          if (filePaths.length > 0) {
            console.log(`Deleting ${filePaths.length} file(s) for invoice ${invoice.number}:`, filePaths)
            
            const { data: deleteData, error: storageError } = await supabaseAdmin.storage
              .from('invoices')
              .remove(filePaths)

            if (storageError) {
              console.error('Error deleting files from storage:', storageError)
              // Continue with database deletion even if storage deletion fails
              // This prevents orphaned database records if storage cleanup fails
            } else {
              console.log('Successfully deleted files from storage:', deleteData)
            }
          }
        }
      } catch (parseError) {
        console.error('Error parsing internal_notes for file deletion:', parseError)
        // Continue with deletion even if parsing fails (might be old format or invalid JSON)
      }
    }

    // Delete invoice from database (CASCADE will handle invoice_items)
    const { error: deleteError } = await db.invoices()
      .delete()
      .eq('id', id)
      .eq('company_id', companyId)

    if (deleteError) {
      handleSupabaseError(deleteError, 'delete invoice')
      return
    }

    console.log(`Invoice ${invoice.number} deleted successfully`)

    // Log audit event
    try {
      await createAuditLog(
        companyId!,
        req.user!.id,
        req.user!.name,
        'INVOICE_DELETED',
        'INVOICE',
        id,
        {
          invoiceNumber: invoice.number
        },
        req.ip,
        req.get('User-Agent')
      )
    } catch (auditError) {
      console.error('Error creating audit log:', auditError)
    }

    res.json({
      success: true,
      message: 'Invoice deleted successfully'
    })

  } catch (error) {
    console.error('Error deleting invoice:', error)
    handleSupabaseError(error, 'delete invoice')
  }
})
